name: Deploy to Dev

on:
  push:
    branches: [main]
    paths:
      # Only trigger on actual code/infrastructure changes
      - 'frontend/**'
      - 'backend/**'
      - 'terraform/deploy/**'
      - 'docker-compose.yml'
      - '.github/workflows/ci-dev.yml'  # Trigger if THIS workflow changes
  workflow_dispatch:

# Prevent deployments and destroys from running simultaneously
concurrency:
  group: terraform-dev  # Shared with destroy workflow to prevent conflicts
  cancel-in-progress: false  # Queue workflows instead of canceling

env:
  AWS_REGION: us-east-1
  ENVIRONMENT: dev

jobs:
  # Code Quality Checks - Run first, fail fast if code doesn't meet standards
  frontend-quality:
    runs-on: ubuntu-latest
    # Only run if frontend, shared packages, or workflow changed
    if: |
      contains(github.event.head_commit.modified, 'frontend/') ||
      contains(github.event.head_commit.modified, 'packages/') ||
      contains(github.event.head_commit.modified, '.github/workflows/ci-dev.yml') ||
      contains(github.event.head_commit.added, 'frontend/') ||
      contains(github.event.head_commit.added, 'packages/') ||
      contains(github.event.head_commit.added, '.github/workflows/ci-dev.yml')
    defaults:
      run:
        working-directory: ./frontend
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Build unit-conversion package
        run: |
          cd ../packages/unit-conversion/typescript
          npm ci
          npm run build

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

      - name: Run TypeScript check
        run: npm run type-check

      - name: Run Prettier check
        run: npm run format-check

  backend-quality:
    runs-on: ubuntu-latest
    # Only run if backend, shared packages, or workflow changed
    if: |
      contains(github.event.head_commit.modified, 'backend/') ||
      contains(github.event.head_commit.modified, 'packages/') ||
      contains(github.event.head_commit.modified, '.github/workflows/ci-dev.yml') ||
      contains(github.event.head_commit.added, 'backend/') ||
      contains(github.event.head_commit.added, 'packages/') ||
      contains(github.event.head_commit.added, '.github/workflows/ci-dev.yml')
    defaults:
      run:
        working-directory: ./backend
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"

      - name: Restore dependencies
        run: dotnet restore

      - name: Run dotnet format check
        run: dotnet format --verify-no-changes --verbosity diagnostic

      - name: Build solution
        run: dotnet build --no-restore

      - name: Run tests
        run: dotnet test --no-build --verbosity normal

  check-infrastructure:
    runs-on: ubuntu-latest
    needs: [frontend-quality, backend-quality]
    # Run even if quality checks were skipped (but not if they failed)
    if: |
      always() &&
      (needs.frontend-quality.result == 'success' || needs.frontend-quality.result == 'skipped') &&
      (needs.backend-quality.result == 'success' || needs.backend-quality.result == 'skipped')
    outputs:
      has-secrets: ${{ steps.check.outputs.has-secrets }}
    steps:
      - name: Check if AWS infrastructure is configured
        id: check
        run: |
          if [ -z "${{ secrets.ECR_IDENTITY_SERVICE_URL }}" ]; then
            echo "âš ï¸ AWS infrastructure not yet deployed"
            echo "ğŸ“‹ To enable deployments:"
            echo "   1. Run: cd terraform/setup && terraform init && terraform apply"
            echo "   2. Configure GitHub secrets (see docs/GITHUB_SECRETS.md)"
            echo "   3. Deployments will run automatically on next push"
            echo "has-secrets=false" >> $GITHUB_OUTPUT
          else
            echo "âœ… AWS infrastructure configured - proceeding with deployment"
            echo "has-secrets=true" >> $GITHUB_OUTPUT
          fi

  build-and-push:
    runs-on: ubuntu-latest
    needs: [frontend-quality, backend-quality, check-infrastructure]
    # Only run if AWS infrastructure is configured
    if: ${{ needs.check-infrastructure.outputs.has-secrets == 'true' }}
    outputs:
      identity-image: ${{ steps.build-identity.outputs.image }}
      gateway-image: ${{ steps.build-gateway.outputs.image }}
      data-image: ${{ steps.build-data.outputs.image }}
      frontend-image: ${{ steps.build-frontend.outputs.image }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Identity Service
        id: build-identity
        run: |
          IMAGE_TAG="${GITHUB_SHA:0:7}"
          docker build -f backend/IdentityService/Dockerfile -t ${{ secrets.ECR_IDENTITY_SERVICE_URL }}:$IMAGE_TAG -t ${{ secrets.ECR_IDENTITY_SERVICE_URL }}:latest .
          docker push ${{ secrets.ECR_IDENTITY_SERVICE_URL }}:$IMAGE_TAG
          docker push ${{ secrets.ECR_IDENTITY_SERVICE_URL }}:latest
          echo "image=${{ secrets.ECR_IDENTITY_SERVICE_URL }}:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Build and push API Gateway
        id: build-gateway
        run: |
          IMAGE_TAG="${GITHUB_SHA:0:7}"
          docker build -f backend/ApiGateway/Dockerfile -t ${{ secrets.ECR_API_GATEWAY_URL }}:$IMAGE_TAG -t ${{ secrets.ECR_API_GATEWAY_URL }}:latest .
          docker push ${{ secrets.ECR_API_GATEWAY_URL }}:$IMAGE_TAG
          docker push ${{ secrets.ECR_API_GATEWAY_URL }}:latest
          echo "image=${{ secrets.ECR_API_GATEWAY_URL }}:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Build and push Data Service
        id: build-data
        run: |
          IMAGE_TAG="${GITHUB_SHA:0:7}"
          docker build -f backend/DataService/Dockerfile -t ${{ secrets.ECR_DATA_SERVICE_URL }}:$IMAGE_TAG -t ${{ secrets.ECR_DATA_SERVICE_URL }}:latest .
          docker push ${{ secrets.ECR_DATA_SERVICE_URL }}:$IMAGE_TAG
          docker push ${{ secrets.ECR_DATA_SERVICE_URL }}:latest
          echo "image=${{ secrets.ECR_DATA_SERVICE_URL }}:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Build and push Frontend
        id: build-frontend
        run: |
          IMAGE_TAG="${GITHUB_SHA:0:7}"
          docker build -f frontend/Dockerfile -t ${{ secrets.ECR_FRONTEND_URL }}:$IMAGE_TAG -t ${{ secrets.ECR_FRONTEND_URL }}:latest .
          docker push ${{ secrets.ECR_FRONTEND_URL }}:$IMAGE_TAG
          docker push ${{ secrets.ECR_FRONTEND_URL }}:latest
          echo "image=${{ secrets.ECR_FRONTEND_URL }}:$IMAGE_TAG" >> $GITHUB_OUTPUT

  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: [check-infrastructure, build-and-push]
    # Only run if build-and-push succeeded
    if: ${{ needs.check-infrastructure.outputs.has-secrets == 'true' && needs.build-and-push.result == 'success' }}
    environment: dev

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.9.0"

      - name: Create backend config
        run: |
          cat > backend-config.tfvars <<EOF
          bucket         = "${{ secrets.S3_BUCKET_NAME }}"
          key            = "deploy/dev/terraform.tfstate"
          region         = "${{ env.AWS_REGION }}"
          dynamodb_table = "${{ secrets.DYNAMODB_TABLE_NAME }}"
          EOF
        working-directory: ./terraform/deploy

      # NOTE: No longer creating terraform.tfvars!
      # All infrastructure values (VPC, ECR, Cognito, etc.) are now automatically
      # pulled from terraform_remote_state in setup. Only environment-specific
      # variables are in environments/dev.tfvars.

      - name: Check if backend resources exist
        id: check-backend
        run: |
          # Check if S3 bucket exists
          if ! aws s3 ls s3://${{ secrets.S3_BUCKET_NAME }} 2>/dev/null; then
            echo "âŒ ERROR: S3 bucket '${{ secrets.S3_BUCKET_NAME }}' does not exist!"
            echo "Please run Phase 4 (AWS Infrastructure Setup) first:"
            echo "  cd terraform/setup"
            echo "  terraform init"
            echo "  terraform apply"
            exit 1
          fi

          # Check if DynamoDB table exists
          if ! aws dynamodb describe-table --table-name ${{ secrets.DYNAMODB_TABLE_NAME }} 2>/dev/null; then
            echo "âŒ ERROR: DynamoDB table '${{ secrets.DYNAMODB_TABLE_NAME }}' does not exist!"
            echo "Please run Phase 4 (AWS Infrastructure Setup) first:"
            echo "  cd terraform/setup"
            echo "  terraform init"
            echo "  terraform apply"
            exit 1
          fi

          echo "âœ… Backend resources verified"

      - name: Terraform Init
        run: terraform init -backend-config=backend-config.tfvars
        working-directory: ./terraform/deploy

      - name: Terraform Plan
        run: terraform plan -var-file="environments/dev.tfvars" -out=tfplan
        working-directory: ./terraform/deploy

      - name: Terraform Apply
        run: |
          echo "ğŸš€ Applying Terraform configuration..."
          terraform apply -auto-approve tfplan

          echo ""
          echo "ğŸ“‹ Checking if S3/CloudFront module resources were created..."
          terraform state list | grep "module.s3_cloudfront" || echo "âš ï¸ No S3/CloudFront resources in state!"
        working-directory: ./terraform/deploy

      - name: Get CloudFront domain for CORS
        id: get-cloudfront
        run: |
          echo "ğŸ“Š Getting CloudFront domain..."
          CLOUDFRONT_DOMAIN=$(terraform output -raw cloudfront_domain_name || echo "")
          echo "CloudFront Domain: $CLOUDFRONT_DOMAIN"
          echo "cloudfront_domain=$CLOUDFRONT_DOMAIN" >> $GITHUB_OUTPUT
        working-directory: ./terraform/deploy

      - name: Update API Gateway CORS (Second Apply)
        if: steps.get-cloudfront.outputs.cloudfront_domain != ''
        run: |
          echo "ğŸ”„ Updating API Gateway with CORS configuration..."
          echo "CloudFront Domain: ${{ steps.get-cloudfront.outputs.cloudfront_domain }}"

          # Second apply to update API Gateway with CloudFront domain for CORS
          terraform apply -auto-approve \
            -var-file="environments/dev.tfvars" \
            -var="cloudfront_domain_override=${{ steps.get-cloudfront.outputs.cloudfront_domain }}"

          echo "âœ… API Gateway CORS configured!"
        working-directory: ./terraform/deploy

      - name: Get outputs
        id: tf-outputs
        run: |
          echo "ğŸ“Š Getting Terraform outputs..."

          # Show all outputs for debugging
          echo "All outputs:"
          terraform output

          # Get individual outputs with explicit logging
          echo ""
          echo "Capturing outputs to GITHUB_OUTPUT..."

          # Get outputs using environment variables as intermediate (avoids GitHub Actions metadata)
          export TF_RDS=$(terraform output -raw rds_endpoint)
          export TF_ID_SVC=$(terraform output -raw identity_service_url)
          export TF_API_GW=$(terraform output -raw api_gateway_url)
          export TF_DATA_SVC=$(terraform output -raw data_service_url)
          export TF_CF_DOMAIN=$(terraform output -raw cloudfront_domain_name)
          export TF_S3_BUCKET=$(terraform output -raw frontend_s3_bucket_name)

          echo "Captured values:"
          echo "  rds_endpoint: '$TF_RDS'"
          echo "  identity_service_url: '$TF_ID_SVC'"
          echo "  api_gateway_url: '$TF_API_GW'"
          echo "  data_service_url: '$TF_DATA_SVC'"
          echo "  cloudfront_domain: '$TF_CF_DOMAIN'"
          echo "  s3_bucket: '$TF_S3_BUCKET'"

          # Write to GITHUB_OUTPUT using printf (more reliable than echo)
          printf "rds_endpoint=%s\n" "$TF_RDS" >> "$GITHUB_OUTPUT"
          printf "identity_service_url=%s\n" "$TF_ID_SVC" >> "$GITHUB_OUTPUT"
          printf "api_gateway_url=%s\n" "$TF_API_GW" >> "$GITHUB_OUTPUT"
          printf "data_service_url=%s\n" "$TF_DATA_SVC" >> "$GITHUB_OUTPUT"
          printf "cloudfront_domain=%s\n" "$TF_CF_DOMAIN" >> "$GITHUB_OUTPUT"
          printf "s3_bucket=%s\n" "$TF_S3_BUCKET" >> "$GITHUB_OUTPUT"

          echo ""
          echo "âœ… All outputs captured successfully"
        working-directory: ./terraform/deploy

    outputs:
      rds_endpoint: ${{ steps.tf-outputs.outputs.rds_endpoint }}
      identity_service_url: ${{ steps.tf-outputs.outputs.identity_service_url }}
      api_gateway_url: ${{ steps.tf-outputs.outputs.api_gateway_url }}
      data_service_url: ${{ steps.tf-outputs.outputs.data_service_url }}
      cloudfront_domain: ${{ steps.tf-outputs.outputs.cloudfront_domain }}
      s3_bucket: ${{ steps.tf-outputs.outputs.s3_bucket }}

  # Check if backend files changed
  check-backend-changes:
    runs-on: ubuntu-latest
    outputs:
      backend_changed: ${{ steps.filter.outputs.backend }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            backend:
              - 'backend/**'
              - 'Dockerfile.*'
              - '.github/workflows/ci-dev.yml'

  deploy-services:
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, build-and-push, check-backend-changes]
    if: needs.build-and-push.result == 'success' && needs.check-backend-changes.outputs.backend_changed == 'true'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Trigger App Runner service deployments
        run: |
          echo "ğŸš€ Triggering App Runner service deployments..."
          echo "This will pull the latest :latest tagged images from ECR"
          echo ""

          # Get service ARNs
          IDENTITY_ARN=$(aws apprunner list-services \
            --query "ServiceSummaryList[?contains(ServiceName, '${{ env.ENVIRONMENT }}-identity-service')].ServiceArn | [0]" \
            --output text)

          DATA_ARN=$(aws apprunner list-services \
            --query "ServiceSummaryList[?contains(ServiceName, '${{ env.ENVIRONMENT }}-data-service')].ServiceArn | [0]" \
            --output text)

          API_ARN=$(aws apprunner list-services \
            --query "ServiceSummaryList[?contains(ServiceName, '${{ env.ENVIRONMENT }}-api-gateway')].ServiceArn | [0]" \
            --output text)

          # Trigger deployments
          echo "ğŸ“¦ Deploying Identity Service..."
          if [ -n "$IDENTITY_ARN" ] && [ "$IDENTITY_ARN" != "None" ]; then
            aws apprunner start-deployment --service-arn "$IDENTITY_ARN"
            echo "âœ… Identity Service deployment initiated"
          else
            echo "âš ï¸  Identity Service not found, skipping"
          fi

          echo ""
          echo "ğŸ“¦ Deploying Data Service..."
          if [ -n "$DATA_ARN" ] && [ "$DATA_ARN" != "None" ]; then
            aws apprunner start-deployment --service-arn "$DATA_ARN"
            echo "âœ… Data Service deployment initiated"
          else
            echo "âš ï¸  Data Service not found, skipping"
          fi

          echo ""
          echo "â­ï¸  Skipping API Gateway deployment"
          echo "   (Already deployed by update-cors job)"

          echo ""
          echo "â³ Note: Deployments take ~3-5 minutes to complete"
          echo "   Services will automatically apply database migrations on startup"
          echo "   Monitor logs: aws logs tail /aws/apprunner/navarch-studio-${{ env.ENVIRONMENT }}-data-service --since 5m --region ${{ env.AWS_REGION }}"

  deploy-frontend:
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infrastructure]
    # Always run - we'll check outputs in the first step and fail fast if missing
    if: always() && needs.deploy-infrastructure.result == 'success'
    env:
      # Pass outputs as environment variables (bypasses GitHub's *** redaction)
      S3_BUCKET_NAME: ${{ needs.deploy-infrastructure.outputs.s3_bucket }}
      API_GATEWAY_URL: ${{ needs.deploy-infrastructure.outputs.api_gateway_url }}
      CLOUDFRONT_DOMAIN: ${{ needs.deploy-infrastructure.outputs.cloudfront_domain }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Discover S3 bucket name from AWS
        id: discover-s3
        run: |
          echo "ğŸ” Querying AWS for frontend S3 bucket..."
          # List buckets and filter for the pattern: *-dev-frontend
          BUCKET_NAME=$(aws s3api list-buckets --query "Buckets[?contains(Name, '-dev-frontend')].Name | [0]" --output text)

          if [ -z "$BUCKET_NAME" ] || [ "$BUCKET_NAME" == "None" ]; then
            echo "âŒ ERROR: Could not find S3 bucket matching pattern '*-dev-frontend'"
            exit 1
          fi

          echo "âœ… Found S3 bucket: $BUCKET_NAME"
          echo "bucket_name=$BUCKET_NAME" >> $GITHUB_OUTPUT

      - name: Check required outputs
        run: |
          echo "ğŸ” Checking deployment configuration..."
          echo "S3 Bucket: '${{ steps.discover-s3.outputs.bucket_name }}'"
          echo "API Gateway URL: '$API_GATEWAY_URL'"
          echo "CloudFront Domain: '$CLOUDFRONT_DOMAIN'"

          if [ -z "$API_GATEWAY_URL" ]; then
            echo "âŒ ERROR: API Gateway URL is empty! Cannot deploy frontend."
            exit 1
          fi

          echo "âœ… All required configuration available"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Build unit-conversion package
        run: |
          cd packages/unit-conversion/typescript
          npm ci
          npm run build

      - name: Install dependencies
        run: npm ci
        working-directory: ./frontend

      - name: Build frontend
        run: npm run build
        working-directory: ./frontend
        env:
          VITE_API_URL: ${{ env.API_GATEWAY_URL }}
          VITE_AUTH_MODE: cognito
          VITE_COGNITO_USER_POOL_ID: ${{ secrets.COGNITO_USER_POOL_ID }}
          VITE_COGNITO_CLIENT_ID: ${{ secrets.COGNITO_USER_POOL_CLIENT_ID }}
          VITE_AWS_REGION: ${{ env.AWS_REGION }}

      - name: Create runtime config.json
        run: |
          cat > ./frontend/dist/config.json <<EOF
          {
            "apiUrl": "${{ env.API_GATEWAY_URL }}",
            "authMode": "cognito",
            "cognitoUserPoolId": "${{ secrets.COGNITO_USER_POOL_ID }}",
            "cognitoClientId": "${{ secrets.COGNITO_USER_POOL_CLIENT_ID }}",
            "awsRegion": "${{ env.AWS_REGION }}"
          }
          EOF
          echo "âœ… Created config.json for runtime configuration"
          cat ./frontend/dist/config.json

      - name: Deploy to S3
        run: |
          aws s3 sync ./frontend/dist/ s3://${{ steps.discover-s3.outputs.bucket_name }} --delete

      - name: Get CloudFront Distribution ID
        id: get-cf-id
        run: |
          # Query by bucket name in origin instead of aliases (distributions without custom domains don't have aliases)
          BUCKET_NAME="${{ steps.discover-s3.outputs.bucket_name }}"
          echo "Looking for CloudFront distribution with origin: $BUCKET_NAME"

          DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Origins.Items[?contains(DomainName, '$BUCKET_NAME')]].Id | [0]" \
            --output text)

          if [ -z "$DISTRIBUTION_ID" ] || [ "$DISTRIBUTION_ID" == "None" ]; then
            echo "âŒ ERROR: Could not find CloudFront distribution for bucket $BUCKET_NAME"
            exit 1
          fi

          echo "âœ… Found CloudFront distribution: $DISTRIBUTION_ID"
          echo "distribution_id=$DISTRIBUTION_ID" >> $GITHUB_OUTPUT

      - name: Invalidate CloudFront cache
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ steps.get-cf-id.outputs.distribution_id }} \
            --paths "/*"

  smoke-tests:
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, deploy-frontend]
    # Run even if frontend deployment was skipped
    if: always() && needs.deploy-infrastructure.result == 'success'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Test Identity Service health
        run: |
          echo "Testing Identity Service at ${{ needs.deploy-infrastructure.outputs.identity_service_url }}/health"
          curl -f ${{ needs.deploy-infrastructure.outputs.identity_service_url }}/health || exit 1

      - name: Test API Gateway health
        run: |
          echo "Testing API Gateway at ${{ needs.deploy-infrastructure.outputs.api_gateway_url }}/health"
          curl -f ${{ needs.deploy-infrastructure.outputs.api_gateway_url }}/health || exit 1

      - name: Test Data Service health
        run: |
          echo "Testing Data Service at ${{ needs.deploy-infrastructure.outputs.data_service_url }}/health"
          curl -f ${{ needs.deploy-infrastructure.outputs.data_service_url }}/health || exit 1

      - name: Test Frontend
        if: needs.deploy-infrastructure.outputs.s3_bucket != '' && needs.deploy-infrastructure.outputs.cloudfront_domain != ''
        run: |
          echo "Testing Frontend at https://${{ needs.deploy-infrastructure.outputs.cloudfront_domain }}"
          curl -f https://${{ needs.deploy-infrastructure.outputs.cloudfront_domain }} || exit 1

      - name: Frontend deployment was skipped
        if: needs.deploy-infrastructure.outputs.s3_bucket == '' || needs.deploy-infrastructure.outputs.cloudfront_domain == ''
        run: |
          echo "â­ï¸ Frontend deployment was skipped (S3 bucket or CloudFront not available)"
          echo "This is normal if this is a partial deployment."

  notify:
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, smoke-tests]
    if: always()
    env:
      AWS_REGION: us-east-1

    steps:
      - name: Configure AWS credentials
        if: needs.smoke-tests.result == 'success'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get deployment URLs
        if: needs.smoke-tests.result == 'success'
        id: get-urls
        run: |
          # Get S3 bucket
          S3_BUCKET=$(aws s3api list-buckets --query "Buckets[?contains(Name, '-dev-frontend')].Name | [0]" --output text)

          # Get CloudFront distribution domain
          CF_DOMAIN=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Origins.Items[?contains(DomainName, '$S3_BUCKET')]].DomainName | [0]" \
            --output text)

          # Get API Gateway URL (from App Runner)
          API_GW=$(aws apprunner list-services --query "ServiceSummaryList[?contains(ServiceName, '-dev-api-gateway')].ServiceUrl | [0]" --output text)

          echo "cloudfront_url=https://$CF_DOMAIN" >> $GITHUB_OUTPUT
          echo "api_gateway_url=https://$API_GW" >> $GITHUB_OUTPUT

      - name: Notify deployment status
        run: |
          if [ "${{ needs.smoke-tests.result }}" == "success" ]; then
            echo "âœ… Dev deployment successful!"
            echo ""
            echo "ğŸŒ Application URLs:"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "Frontend:    ${{ steps.get-urls.outputs.cloudfront_url }}"
            echo "API Gateway: ${{ steps.get-urls.outputs.api_gateway_url }}"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo ""
            echo "ğŸ’¡ Test your application:"
            echo "   Open: ${{ steps.get-urls.outputs.cloudfront_url }}"
          else
            echo "âŒ Dev deployment failed!"
            echo "Check the logs above for details."
            exit 1
          fi
