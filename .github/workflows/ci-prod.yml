name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag to deploy (e.g., v1.0.0)'
        required: true
        type: string

# Prevent multiple deployments from running simultaneously
concurrency:
  group: terraform-prod  # Shared with destroy workflow to prevent conflicts
  cancel-in-progress: false  # Queue workflows instead of canceling

env:
  AWS_REGION: us-east-1
  ENVIRONMENT: prod

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      identity-image: ${{ steps.build-identity.outputs.image }}
      gateway-image: ${{ steps.build-gateway.outputs.image }}
      data-image: ${{ steps.build-data.outputs.image }}
      frontend-image: ${{ steps.build-frontend.outputs.image }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.version }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Identity Service
        id: build-identity
        run: |
          IMAGE_TAG="${{ github.event.inputs.version }}"
          docker build -f backend/IdentityService/Dockerfile -t ${{ secrets.ECR_IDENTITY_SERVICE_URL }}:$IMAGE_TAG -t ${{ secrets.ECR_IDENTITY_SERVICE_URL }}:prod .
          docker push ${{ secrets.ECR_IDENTITY_SERVICE_URL }}:$IMAGE_TAG
          docker push ${{ secrets.ECR_IDENTITY_SERVICE_URL }}:prod
          echo "image=${{ secrets.ECR_IDENTITY_SERVICE_URL }}:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Build and push API Gateway
        id: build-gateway
        run: |
          IMAGE_TAG="${{ github.event.inputs.version }}"
          docker build -f backend/ApiGateway/Dockerfile -t ${{ secrets.ECR_API_GATEWAY_URL }}:$IMAGE_TAG -t ${{ secrets.ECR_API_GATEWAY_URL }}:prod .
          docker push ${{ secrets.ECR_API_GATEWAY_URL }}:$IMAGE_TAG
          docker push ${{ secrets.ECR_API_GATEWAY_URL }}:prod
          echo "image=${{ secrets.ECR_API_GATEWAY_URL }}:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Build and push Data Service
        id: build-data
        run: |
          IMAGE_TAG="${{ github.event.inputs.version }}"
          docker build -f backend/DataService/Dockerfile -t ${{ secrets.ECR_DATA_SERVICE_URL }}:$IMAGE_TAG -t ${{ secrets.ECR_DATA_SERVICE_URL }}:prod .
          docker push ${{ secrets.ECR_DATA_SERVICE_URL }}:$IMAGE_TAG
          docker push ${{ secrets.ECR_DATA_SERVICE_URL }}:$IMAGE_TAG
          docker push ${{ secrets.ECR_DATA_SERVICE_URL }}:prod
          echo "image=${{ secrets.ECR_DATA_SERVICE_URL }}:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Build and push Frontend
        id: build-frontend
        run: |
          IMAGE_TAG="${{ github.event.inputs.version }}"
          docker build -f frontend/Dockerfile -t ${{ secrets.ECR_FRONTEND_URL }}:$IMAGE_TAG -t ${{ secrets.ECR_FRONTEND_URL }}:prod .
          docker push ${{ secrets.ECR_FRONTEND_URL }}:$IMAGE_TAG
          docker push ${{ secrets.ECR_FRONTEND_URL }}:prod
          echo "image=${{ secrets.ECR_FRONTEND_URL }}:$IMAGE_TAG" >> $GITHUB_OUTPUT

  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: build-and-push
    environment:
      name: production
      url: https://${{ steps.tf-outputs.outputs.cloudfront_domain }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.version }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.9.0"

      - name: Create backend config
        run: |
          cat > backend-config.tfvars <<EOF
          bucket         = "${{ secrets.S3_BUCKET_NAME }}"
          key            = "deploy/prod/terraform.tfstate"
          region         = "${{ env.AWS_REGION }}"
          dynamodb_table = "${{ secrets.DYNAMODB_TABLE_NAME }}"
          EOF
        working-directory: ./terraform/deploy

      # NOTE: No longer creating terraform.tfvars!
      # All infrastructure values (VPC, ECR, Cognito, etc.) are now automatically
      # pulled from terraform_remote_state in setup. Only environment-specific
      # variables are in environments/prod.tfvars.

      - name: Check if backend resources exist
        id: check-backend
        run: |
          # Check if S3 bucket exists
          if ! aws s3 ls s3://${{ secrets.S3_BUCKET_NAME }} 2>/dev/null; then
            echo "‚ùå ERROR: S3 bucket '${{ secrets.S3_BUCKET_NAME }}' does not exist!"
            echo "Please run Phase 4 (AWS Infrastructure Setup) first:"
            echo "  cd terraform/setup"
            echo "  terraform init"
            echo "  terraform apply"
            exit 1
          fi

          # Check if DynamoDB table exists
          if ! aws dynamodb describe-table --table-name ${{ secrets.DYNAMODB_TABLE_NAME }} 2>/dev/null; then
            echo "‚ùå ERROR: DynamoDB table '${{ secrets.DYNAMODB_TABLE_NAME }}' does not exist!"
            echo "Please run Phase 4 (AWS Infrastructure Setup) first:"
            echo "  cd terraform/setup"
            echo "  terraform init"
            echo "  terraform apply"
            exit 1
          fi

          echo "‚úÖ Backend resources verified"

      - name: Terraform Init
        run: terraform init -backend-config=backend-config.tfvars
        working-directory: ./terraform/deploy

      - name: Terraform Plan
        run: terraform plan -var-file="environments/prod.tfvars" -out=tfplan
        working-directory: ./terraform/deploy

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan
        working-directory: ./terraform/deploy

      - name: Get CloudFront domain for CORS
        id: get-cloudfront
        run: |
          echo "üìä Getting CloudFront domain..."
          CLOUDFRONT_DOMAIN=$(terraform output -raw cloudfront_domain_name || echo "")
          echo "CloudFront Domain: $CLOUDFRONT_DOMAIN"
          echo "cloudfront_domain=$CLOUDFRONT_DOMAIN" >> $GITHUB_OUTPUT
        working-directory: ./terraform/deploy

      - name: Update API Gateway CORS (Second Apply)
        if: steps.get-cloudfront.outputs.cloudfront_domain != ''
        run: |
          echo "üîÑ Updating API Gateway with CORS configuration..."
          echo "CloudFront Domain: ${{ steps.get-cloudfront.outputs.cloudfront_domain }}"

          # Second apply to update API Gateway with CloudFront domain for CORS
          terraform apply -auto-approve \
            -var-file="environments/prod.tfvars" \
            -var="cloudfront_domain_override=${{ steps.get-cloudfront.outputs.cloudfront_domain }}"

          echo "‚úÖ API Gateway CORS configured!"
        working-directory: ./terraform/deploy

      - name: Get outputs
        id: tf-outputs
        run: |
          echo "rds_endpoint=$(terraform output -raw rds_endpoint)" >> $GITHUB_OUTPUT
          echo "identity_service_url=$(terraform output -raw identity_service_url)" >> $GITHUB_OUTPUT
          echo "api_gateway_url=$(terraform output -raw api_gateway_url)" >> $GITHUB_OUTPUT
          echo "data_service_url=$(terraform output -raw data_service_url)" >> $GITHUB_OUTPUT
          echo "cloudfront_domain=$(terraform output -raw cloudfront_domain_name)" >> $GITHUB_OUTPUT
          echo "s3_bucket=$(terraform output -raw frontend_s3_bucket_name)" >> $GITHUB_OUTPUT
        working-directory: ./terraform/deploy

    outputs:
      rds_endpoint: ${{ steps.tf-outputs.outputs.rds_endpoint }}
      identity_service_url: ${{ steps.tf-outputs.outputs.identity_service_url }}
      api_gateway_url: ${{ steps.tf-outputs.outputs.api_gateway_url }}
      data_service_url: ${{ steps.tf-outputs.outputs.data_service_url }}
      cloudfront_domain: ${{ steps.tf-outputs.outputs.cloudfront_domain }}
      s3_bucket: ${{ steps.tf-outputs.outputs.s3_bucket }}

  run-migrations:
    runs-on: ubuntu-latest
    needs: deploy-infrastructure

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.version }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check for migrations
        id: check-migrations
        run: |
          if [ -n "$(ls -A database/migrations 2>/dev/null)" ]; then
            echo "has_migrations=true" >> $GITHUB_OUTPUT
          else
            echo "has_migrations=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è No Flyway migrations found. Skipping migration step."
            echo ""
            echo "üí° Note: This project uses EF Core migrations for DataService."
            echo "‚úÖ Migrations are applied AUTOMATICALLY when services start:"
            echo "   - DataService checks for pending migrations at startup"
            echo "   - Applies them automatically in production/staging"
            echo "   - Logs migration status to CloudWatch"
            echo "   - Service health check verifies successful migration"
            echo ""
            echo "üìã To verify migrations after deployment:"
            echo "   aws logs tail /aws/apprunner/navarch-studio-prod-data-service --since 5m --region us-east-1"
            echo "   Look for: '‚úÖ Migrations applied successfully' or '‚úÖ Database schema is up to date'"
          fi

      - name: Run database migrations
        if: steps.check-migrations.outputs.has_migrations == 'true'
        run: |
          docker run --rm \
            -v $PWD/database/migrations:/flyway/sql \
            flyway/flyway:10-alpine \
            -url=jdbc:postgresql://${{ needs.deploy-infrastructure.outputs.rds_endpoint }}:5432/${{ secrets.RDS_DATABASE }} \
            -user=${{ secrets.RDS_USERNAME }} \
            -password=${{ secrets.RDS_PASSWORD }} \
            -locations=filesystem:/flyway/sql \
            migrate

  deploy-services:
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, build-and-push]
    if: needs.build-and-push.result == 'success'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Trigger App Runner service deployments
        run: |
          echo "üöÄ Triggering App Runner service deployments..."
          echo "This will pull the latest :latest tagged images from ECR"
          echo ""

          # Get service ARNs
          IDENTITY_ARN=$(aws apprunner list-services \
            --query "ServiceSummaryList[?contains(ServiceName, '${{ env.ENVIRONMENT }}-identity-service')].ServiceArn | [0]" \
            --output text)

          DATA_ARN=$(aws apprunner list-services \
            --query "ServiceSummaryList[?contains(ServiceName, '${{ env.ENVIRONMENT }}-data-service')].ServiceArn | [0]" \
            --output text)

          API_ARN=$(aws apprunner list-services \
            --query "ServiceSummaryList[?contains(ServiceName, '${{ env.ENVIRONMENT }}-api-gateway')].ServiceArn | [0]" \
            --output text)

          # Trigger deployments
          echo "üì¶ Deploying Identity Service..."
          if [ -n "$IDENTITY_ARN" ] && [ "$IDENTITY_ARN" != "None" ]; then
            aws apprunner start-deployment --service-arn "$IDENTITY_ARN"
            echo "‚úÖ Identity Service deployment initiated"
          else
            echo "‚ö†Ô∏è  Identity Service not found, skipping"
          fi

          echo ""
          echo "üì¶ Deploying Data Service..."
          if [ -n "$DATA_ARN" ] && [ "$DATA_ARN" != "None" ]; then
            aws apprunner start-deployment --service-arn "$DATA_ARN"
            echo "‚úÖ Data Service deployment initiated"
          else
            echo "‚ö†Ô∏è  Data Service not found, skipping"
          fi

          echo ""
          echo "üì¶ Deploying API Gateway..."
          if [ -n "$API_ARN" ] && [ "$API_ARN" != "None" ]; then
            aws apprunner start-deployment --service-arn "$API_ARN"
            echo "‚úÖ API Gateway deployment initiated"
          else
            echo "‚ö†Ô∏è  API Gateway not found, skipping"
          fi

          echo ""
          echo "‚è≥ Note: Deployments take ~3-5 minutes to complete"
          echo "   Services will automatically apply database migrations on startup"
          echo "   Monitor logs: aws logs tail /aws/apprunner/navarch-studio-${{ env.ENVIRONMENT }}-data-service --since 5m --region ${{ env.AWS_REGION }}"

      - name: Wait for services to start
        run: |
          echo "‚è≥ Waiting for services to start and apply migrations..."
          echo "   App Runner deployments typically take 3-5 minutes"
          sleep 180  # Wait 3 minutes for services to start

      - name: Verify migrations applied
        run: |
          echo "üîç Verifying database migrations were applied successfully..."

          # Log group names for services
          IDENTITY_LOG_GROUP="/aws/apprunner/navarch-studio-${{ env.ENVIRONMENT }}-identity-service"
          DATA_LOG_GROUP="/aws/apprunner/navarch-studio-${{ env.ENVIRONMENT }}-data-service"

          # Check Identity Service migrations
          echo ""
          echo "Checking Identity Service migrations..."
          IDENTITY_MIGRATION_SUCCESS=$(aws logs filter-log-events \
            --log-group-name "$IDENTITY_LOG_GROUP" \
            --start-time $(($(date +%s) - 600))000 \
            --filter-pattern "Migrations applied successfully" \
            --query 'events[*].message' \
            --output text 2>/dev/null || echo "")

          IDENTITY_MIGRATION_UP_TO_DATE=$(aws logs filter-log-events \
            --log-group-name "$IDENTITY_LOG_GROUP" \
            --start-time $(($(date +%s) - 600))000 \
            --filter-pattern "Database schema is up to date" \
            --query 'events[*].message' \
            --output text 2>/dev/null || echo "")

          if [ -n "$IDENTITY_MIGRATION_SUCCESS" ] || [ -n "$IDENTITY_MIGRATION_UP_TO_DATE" ]; then
            echo "‚úÖ Identity Service: Migrations verified"
          else
            echo "‚ö†Ô∏è  Identity Service: Migration status inconclusive (may still be starting)"
            echo "   Check logs manually: aws logs tail $IDENTITY_LOG_GROUP --since 5m --region ${{ env.AWS_REGION }}"
          fi

          # Check Data Service migrations
          echo ""
          echo "Checking Data Service migrations..."
          DATA_MIGRATION_SUCCESS=$(aws logs filter-log-events \
            --log-group-name "$DATA_LOG_GROUP" \
            --start-time $(($(date +%s) - 600))000 \
            --filter-pattern "Migrations applied successfully" \
            --query 'events[*].message' \
            --output text 2>/dev/null || echo "")

          DATA_MIGRATION_UP_TO_DATE=$(aws logs filter-log-events \
            --log-group-name "$DATA_LOG_GROUP" \
            --start-time $(($(date +%s) - 600))000 \
            --filter-pattern "Database schema is up to date" \
            --query 'events[*].message' \
            --output text 2>/dev/null || echo "")

          if [ -n "$DATA_MIGRATION_SUCCESS" ] || [ -n "$DATA_MIGRATION_UP_TO_DATE" ]; then
            echo "‚úÖ Data Service: Migrations verified"
          else
            echo "‚ö†Ô∏è  Data Service: Migration status inconclusive (may still be starting)"
            echo "   Check logs manually: aws logs tail $DATA_LOG_GROUP --since 5m --region ${{ env.AWS_REGION }}"
          fi

          # Check for migration errors (fail if found)
          echo ""
          echo "Checking for migration errors..."
          IDENTITY_ERROR=$(aws logs filter-log-events \
            --log-group-name "$IDENTITY_LOG_GROUP" \
            --start-time $(($(date +%s) - 600))000 \
            --filter-pattern "ERROR Migration check failed" \
            --query 'events[*].message' \
            --output text 2>/dev/null || echo "")

          DATA_ERROR=$(aws logs filter-log-events \
            --log-group-name "$DATA_LOG_GROUP" \
            --start-time $(($(date +%s) - 600))000 \
            --filter-pattern "ERROR Migration check failed" \
            --query 'events[*].message' \
            --output text 2>/dev/null || echo "")

          if [ -n "$IDENTITY_ERROR" ]; then
            echo "‚ùå Identity Service migration failed!"
            echo "$IDENTITY_ERROR"
            exit 1
          fi

          if [ -n "$DATA_ERROR" ]; then
            echo "‚ùå Data Service migration failed!"
            echo "$DATA_ERROR"
            exit 1
          fi

          echo ""
          echo "‚úÖ Migration verification complete"
          echo "   Both services have either applied migrations successfully or are up to date"

  deploy-frontend:
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infrastructure]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.version }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Build unit-conversion package
        run: |
          cd packages/unit-conversion/typescript
          npm ci
          npm run build

      - name: Install dependencies
        run: npm ci
        working-directory: ./frontend

      - name: Build frontend
        run: npm run build
        working-directory: ./frontend
        env:
          VITE_API_URL: https://${{ needs.deploy-infrastructure.outputs.api_gateway_url }}
          VITE_AUTH_MODE: cognito
          VITE_COGNITO_USER_POOL_ID: ${{ secrets.COGNITO_USER_POOL_ID }}
          VITE_COGNITO_CLIENT_ID: ${{ secrets.COGNITO_USER_POOL_CLIENT_ID }}
          VITE_AWS_REGION: ${{ env.AWS_REGION }}

      - name: Deploy to S3
        run: |
          aws s3 sync ./frontend/dist/ s3://${{ needs.deploy-infrastructure.outputs.s3_bucket }} --delete

      - name: Get CloudFront Distribution ID
        id: get-cf-id
        run: |
          DISTRIBUTION_ID=$(aws cloudfront list-distributions --query "DistributionList.Items[?Aliases.Items[?contains(@, '${{ needs.deploy-infrastructure.outputs.cloudfront_domain }}')]].Id | [0]" --output text)
          echo "distribution_id=$DISTRIBUTION_ID" >> $GITHUB_OUTPUT

      - name: Invalidate CloudFront cache
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ steps.get-cf-id.outputs.distribution_id }} \
            --paths "/*"

  smoke-tests:
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, run-migrations, deploy-frontend]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Test Identity Service health
        run: |
          echo "Testing Identity Service at https://${{ needs.deploy-infrastructure.outputs.identity_service_url }}/health"
          curl -f https://${{ needs.deploy-infrastructure.outputs.identity_service_url }}/health || exit 1

      - name: Test API Gateway health
        run: |
          echo "Testing API Gateway at https://${{ needs.deploy-infrastructure.outputs.api_gateway_url }}/health"
          curl -f https://${{ needs.deploy-infrastructure.outputs.api_gateway_url }}/health || exit 1

      - name: Test Data Service health
        run: |
          echo "Testing Data Service at https://${{ needs.deploy-infrastructure.outputs.data_service_url }}/health"
          curl -f https://${{ needs.deploy-infrastructure.outputs.data_service_url }}/health || exit 1

      - name: Test Frontend
        run: |
          echo "Testing Frontend at https://${{ needs.deploy-infrastructure.outputs.cloudfront_domain }}"
          curl -f https://${{ needs.deploy-infrastructure.outputs.cloudfront_domain }} || exit 1

  notify:
    runs-on: ubuntu-latest
    needs: [smoke-tests]
    if: always()

    steps:
      - name: Notify deployment status
        run: |
          if [ "${{ needs.smoke-tests.result }}" == "success" ]; then
            echo "‚úÖ Production deployment successful!"
            echo "Version: ${{ github.event.inputs.version }}"
            echo "Frontend: https://${{ needs.deploy-infrastructure.outputs.cloudfront_domain }}"
            echo "API Gateway: https://${{ needs.deploy-infrastructure.outputs.api_gateway_url }}"
          else
            echo "‚ùå Production deployment failed!"
            exit 1
          fi
